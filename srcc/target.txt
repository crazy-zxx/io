和InputStream类似，OutputStream也提供了close()方法关闭输出流，以便释放系统资源。
要特别注意：OutputStream还提供了一个flush()方法，它的目的是将缓冲区的内容真正输出到目的地。
为什么要有flush()？因为向磁盘、网络写入数据的时候，出于效率的考虑，
操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，
而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个byte[]数组），
等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，
花费的时间几乎是完全一样的，所以OutputStream有个flush()方法，能强制把缓冲区内容输出。
通常情况下，我们不需要调用这个flush()方法，因为缓冲区写满了OutputStream会自动调用它，
并且，在调用close()方法关闭OutputStream之前，也会自动调用flush()方法。
但是，在某些情况下，我们必须手动调用flush()方法。举个栗子：
小明正在开发一款在线聊天软件，当用户输入一句话后，就通过OutputStream的write()方法写入网络流。
小明测试的时候发现，发送方输入后，接收方根本收不到任何信息，怎么肥四？
原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。
如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，
这个时候，接收方会一次性收到大量消息。
解决办法就是每输入一句话后，立刻调用flush()，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。
实际上，InputStream也有缓冲区。例如，从FileInputStream读取一个字节时，
操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。
然后，每次我们调用int read()读取下一个字节时，可以直接返回缓冲区的下一个字节，
避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用read()，
则会触发操作系统的下一次读取并再次填满缓冲区。
FileOutputStream
我们以FileOutputStream为例，演示如何将若干个字节写入文件流：